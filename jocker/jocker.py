
import jocker_config
import logging
import logging.config
import os
import sys
from jingen.jingen import Jingen
import docker
import json
import re
import yaml

DEFAULT_BASE_LOGGING_LEVEL = logging.INFO
DEFAULT_VERBOSE_LOGGING_LEVEL = logging.DEBUG

DEFAULT_CONFIG_FILE = os.path.expanduser("~/.jocker/config.yml")
DEFAULT_DOCKERFILE = "Dockerfile.template"
DEFAULT_VARSFILE = 'varsfile.py'
DEFAULT_OUTPUTFILE = 'Dockerfile'

DEFAULT_DOCKER_CONFIG = {
    'client': {
        'base_url': 'unix://var/run/docker.sock',
        'version': '1.14',
        'timeout': 10
    },
    'build': {
        'quiet': False,
        'fileobj': None,
        'nocache': False,
        'rm': True,
        'stream': False,
        'timeout': None,
        'custom_context': False,
        'encoding': None
    }
}


def init_jocker_logger(base_level=DEFAULT_BASE_LOGGING_LEVEL,
                       verbose_level=DEFAULT_VERBOSE_LOGGING_LEVEL,
                       logging_config=None):
    """initializes a base logger

    you can use this to init a logger in any of your files.
    this will use config.py's LOGGER param and logging.dictConfig to configure
    the logger for you.

    :param int|logging.LEVEL base_level: desired base logging level
    :param int|logging.LEVEL verbose_level: desired verbose logging level
    :param dict logging_dict: dictConfig based configuration.
     used to override the default configuration from config.py
    :rtype: `python logger`
    """
    if logging_config is None:
        logging_config = {}
    logging_config = logging_config or jocker_config.LOGGER
    # TODO: (IMPRV) only perform file related actions if file handler is
    # TODO: (IMPRV) defined.

    log_dir = os.path.expanduser(
        os.path.dirname(
            jocker_config.LOGGER['handlers']['file']['filename']))
    if os.path.isfile(log_dir):
        sys.exit('file {0} exists - log directory cannot be created '
                 'there. please remove the file and try again.'
                 .format(log_dir))
    try:
        logfile = jocker_config.LOGGER['handlers']['file']['filename']
        d = os.path.expanduser(os.path.dirname(logfile))
        if not os.path.exists(d) and not len(d) == 0:
            os.makedirs(d)
        logging.config.dictConfig(logging_config)
        jocker_lgr = logging.getLogger('user')
        # jocker_lgr.setLevel(base_level) if not jocker_config.VERBOSE \
        jocker_lgr.setLevel(base_level)
        return jocker_lgr
    except ValueError as e:
        sys.exit('could not initialize logger.'
                 ' verify your logger config'
                 ' and permissions to write to {0} ({1})'
                 .format(logfile, e))

jocker_lgr = init_jocker_logger()


def _set_global_verbosity_level(is_verbose_output=False):
    """sets the global verbosity level for console and the jocker_lgr logger.

    :param bool is_verbose_output: should be output be verbose
    """
    global verbose_output
    # TODO: (IMPRV) only raise exceptions in verbose mode
    verbose_output = is_verbose_output
    if verbose_output:
        jocker_lgr.setLevel(logging.DEBUG)
    else:
        jocker_lgr.setLevel(logging.INFO)
    # print 'level is: ' + str(jocker_lgr.getEffectiveLevel())


def import_config(config_file):
    """returns a configuration object

    :param string config_file: path to config file
    """
    # get config file path
    config_file = config_file or os.path.join(os.getcwd(), DEFAULT_CONFIG_FILE)
    jocker_lgr.debug('config file is: {}'.format(config_file))
    # append to path for importing
    try:
        jocker_lgr.debug('importing config...')
        with open(config_file, 'r') as c:
            return yaml.safe_load(c.read())
    except IOError as ex:
        jocker_lgr.error(str(ex))
        raise RuntimeError('cannot access config file')
    except ImportError:
        jocker_lgr.warning('config file not found: {}.'.format(config_file))
        raise RuntimeError('missing config file')
    except SyntaxError:
        jocker_lgr.error('config file syntax is malformatted. please fix '
                         'any syntax errors you might have and try again.')
        raise RuntimeError('bad config file')


def run(varsfile=DEFAULT_VARSFILE, templatefile=DEFAULT_DOCKERFILE,
        outputfile=DEFAULT_OUTPUTFILE, build=False,
        dryrun=False, configfile=None, verbose=False):
    """generates a Dockerfile, builds an image and pushes it to Dockerhub

    A `Dockerfile` will be generated by Jinja2 according to the `varsfile`
    imported. If build is not false, an image will be generated from the
    `outputfile` which is the generated Dockerfile and committed to the
    image:tag string supplied to `build`.

    :param string varsfile: path to file with variables.
    :param string templatefile: path to template file to use.
    :param string outputfile: path to output Dockerfile.
    :param build: False or the image:tag to build to.
    :param bool dryrun: mock run.
    :param string configfile: path to yaml file with docker-py config.
    :param bool verbose: verbose output.
    """

    docker_config = import_config(configfile) if configfile \
        else DEFAULT_DOCKER_CONFIG
    client_config = docker_config.get(
        'client', DEFAULT_DOCKER_CONFIG['client'])
    build_config = docker_config.get(
        'build', DEFAULT_DOCKER_CONFIG['build'])

    templates_dir = os.path.dirname(templatefile)
    template_file = os.path.basename(templatefile)

    jocker_lgr.debug('template_file: {0}'.format(template_file))
    jocker_lgr.debug('vars_source: {0}'.format(varsfile))
    jocker_lgr.debug('outputfile: {0}'.format(outputfile))
    jocker_lgr.debug('templates_dir: {0}'.format(templates_dir))

    i = Jingen(
        template_file=template_file,
        vars_source=varsfile,
        output_file=outputfile,
        templates_dir=templates_dir,
        make_file=not dryrun,
        verbose=verbose)
    output = i.generate()

    if dryrun and build:
        jocker_lgr.error('dryrun requested, cannot build.')
        raise JockerError('dryrun requested, cannot build')
    if dryrun:
        jocker_lgr.info(
            'Dryrun requested, potential Dockerfile Output is: \n{0}'.format(
                output))
        return
    if build:
        jocker_lgr.debug('Docker client config is: {0}'.format(client_config))
        c = docker.Client(**client_config)
        build_file = os.path.dirname(os.path.abspath(outputfile))
        jocker_lgr.info('building image')
        jocker_lgr.debug('building docker image from file: {0}'.format(
            os.path.join(build_file, outputfile)))
        jocker_lgr.debug('Creating Image: {0}'.format(build))
        jocker_lgr.debug('Docker build config is: {0}'.format(build_config))
        x = c.build(path=build_file, tag=build, **build_config)
        # parse output. Um.. this makes 'build' work.. err.. wtf?
        jocker_lgr.info('waiting for build process to finish, please hold...')
        lines = [line for line in x]
        try:
            parsed_lines = [json.loads(e).get('stream', '') for e in lines]
        except ValueError:
            # sometimes all the data is sent in a single line ????
            #
            # ValueError: Extra data: line 1 column 87 - line 1 column
            # 33268 (char 86 - 33267)
            line = lines[0]
            # This ONLY works because every ligne is formatted as
            # {"stream": STRING}
            parsed_lines = [
                json.loads(obj).get('stream', '') for obj in
                re.findall('{\s*"stream"\s*:\s*"[^"]*"\s*}', line)
            ]
        for line in parsed_lines:
            jocker_lgr.debug(line)
    jocker_lgr.info('Done')


class JockerError(Exception):
    pass
